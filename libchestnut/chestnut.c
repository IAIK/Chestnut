#define GNU_SOURCE
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <memory.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/resource.h>
#include <elf.h>
#include <seccomp.h> /* libseccomp */
#include <ctype.h>
#include <stdarg.h>
#include <unistd.h>

//dynamic sandboxing
#include <sys/ptrace.h>
#include <sys/user.h>
#ifdef __x86_64__
#include <sys/reg.h>
#else
#include <sys/types.h>
#include <unistd.h>
#include <sys/uio.h>
#endif
#include <errno.h>
#include <signal.h>
#include <sys/wait.h>

#define SEARCH_STRING "Seccomp:"

static inline void freep(void *p) {
  free(*(void**) p);
}
#define _cleanup_free_ __attribute((cleanup(freep)))
#define NUM_SYSCALLS 600

// if we find an exec call, we use dynamic sandboxing
static int exec_needed = 0;

static int child;
static int syscalls_allowed[NUM_SYSCALLS] = {0};
static int status;

static uint64_t nospecrdtsc() {
#ifdef __x86_64__
  uint64_t a, d;
  asm volatile("mfence");
  asm volatile("rdtsc" : "=a"(a), "=d"(d));
  a = (d << 32) | a;
  asm volatile("mfence");
  return a;
#else
  return 0;
#endif
}


static void debug(const char *restrict fmt, ...) {
  if(getenv("DEBUG")) {
    va_list ap;
    va_start(ap, fmt);
    vfprintf(stdout, fmt, ap);
    va_end(ap);
  }
}

static int check_seccomp_active() {
  // check if we already have seccomp filters installed by our parent
  FILE *status = fopen("/proc/self/status", "r");
  if(!status) {
    debug("Cannot parse /proc/self/status, terminating\n");
    exit(1);
  }
  char line[256];
  int seccomp_mode = 0;
  while(fgets(line, sizeof(line), status)) {
    if(strncmp(line, SEARCH_STRING, sizeof(SEARCH_STRING) - 1) != 0)
      continue;

    char *p = line + sizeof(SEARCH_STRING) - 1;
    while(isspace(*p))
      p++;
    seccomp_mode = atoi(p);
    break;
  }
  fclose(status);

  return seccomp_mode;
}

static int parse_syscalls(int **parsed_syscalls) {
  FILE* f = fopen("/proc/self/exe", "rb");
  fseek(f, 0, SEEK_END);
  size_t fsize = ftell(f);
  fseek(f, 0, SEEK_SET);
  char* elf = (char*)malloc(fsize);
  int read = fread(elf, 1, fsize, f);
  (void)read; // just to suppress the warning
  fclose(f);

  Elf64_Ehdr* hdr = (Elf64_Ehdr*)elf;

  Elf64_Shdr* shdr = (Elf64_Shdr*)(elf + hdr->e_shoff);
  Elf64_Shdr symtab = shdr[hdr->e_shstrndx];

  // parse syscall numbers from note section
  _cleanup_free_ char *syscalls = NULL;
  *parsed_syscalls = (int*) malloc(sizeof(int) * 600);
  if(!*parsed_syscalls) {
    debug("Memory allocation failed, terminating now\n");
    exit(1);
  }
  for(int i = 0; i < hdr->e_shnum; i++) {
    if((strcmp((char*)(elf + symtab.sh_offset + shdr[i].sh_name), ".note.syscalls") == 0) && shdr[i].sh_type == SHT_NOTE) {
      Elf64_Nhdr note = *((Elf64_Nhdr*) (elf + shdr[i].sh_offset));
      debug("Syscalls @ %zx (len: %zd, note size: %d, note type: 0x%x)\n", shdr[i].sh_addr, shdr[i].sh_size, note.n_descsz, note.n_type);
      // if note type is 0x402, the section was generated by our compiler
      // Encoding is a whitespace separated list of syscalls as a string
      // if type is 0x0, it was generated by our binary tool
      // all syscalls are padded to 3 bytes, so we need to parse them that way
      if(note.n_type == 0x402) {
        syscalls = (char*) malloc(sizeof(char) * note.n_descsz);
        if(!syscalls) {
          debug("Memory allocation failed, terminating now\n");
          exit(1);
        }
        // section addr + size of the note section to skip meta data + sizeof(uint64_t) to skip the name and its padding for 4-byte alignment
        memcpy(syscalls, (void*)(elf + shdr[i].sh_offset + sizeof(Elf64_Nhdr) + sizeof(uint64_t)), sizeof(char) * note.n_descsz);
        break;
      } else { // end note type check
         int new_size = sizeof(char) * note.n_descsz + (sizeof(char) * (note.n_descsz/3));
        _cleanup_free_ char * tmp = (char*) malloc(sizeof(char) * note.n_descsz);
        syscalls = (char*) malloc(new_size);

        if(!syscalls || !tmp) {
          debug("Memory allocation failed, terminating now\n");
          exit(1);
        }
        // section offset + size of the note section to skip meta data + sizeof(uint64_t) to skip the name and its padding for 4-byte alignment
        memcpy(tmp, (void*)(elf + shdr[i].sh_offset + sizeof(Elf64_Nhdr) + sizeof(uint64_t)), sizeof(char) * note.n_descsz);
        for(int i=0, j=0; i<sizeof(char) * note.n_descsz; i+=3, j+=4) {
          sprintf(&syscalls[j], "%d%d%d ", tmp[i],tmp[i+1],tmp[i+2]);
        }
        syscalls[new_size - 1] = '\0';
        break;
      }
    }
  }
  // tokenize parsed string for each syscall number
  if(syscalls) {
    char *token = strtok(syscalls, " ");
    int pos = 0;
    debug("Syscalls:");
    while(token) {
      int number = atoi(token);
      debug(" %d", number);
      #ifdef __x86_64__
      // if the number is one of the exec calls (last two are x86), we activate dynamic sandboxing
      if(number == 59 || number == 322 || number == 520 || number == 545) {
      #else
       // arm system call numbers for exec
      if(number == 221 || number == 281) {
      #endif
        exec_needed = 1;
      }
      (*parsed_syscalls)[pos++] = number;
      token = strtok(NULL, " ");
    }
    debug("\nFound %d syscalls\n", pos);
    if(exec_needed)
      debug("Exec syscall found, activating dynamic seccomp filtering\n");
    return pos;
  }
  return 0;
}

static void cleanup_tracer() {
  if(getenv("LOGFILE")) {
    /* FILE *prog = fopen("/proc/self/comm", "r"); */
    /* char prog_name[128]; */
    /* if(!prog) */
    /*   sprintf(prog_name, "%s", "unknown"); */
    /* else */
    /*   fgets(prog_name, sizeof(prog_name), prog); */
    /* prog_name[strcspn(prog_name, "\n")] = 0; */
    /* fclose(prog); */
    // save all allowed syscalls to a logfile for debugging purposes
    FILE *file = fopen(getenv("LOGFILE"), "a");
    /* fprintf(file, "%s: ", prog_name); */
    for(int i=0; i<NUM_SYSCALLS; i++) {
      if(syscalls_allowed[i] == 1) {
        fprintf(file, "%d ", i);
      }
    }
    fprintf(file, "\n");
    fclose(file);
  }
}

void sig_handler(int signo) {
  if (signo == SIGINT) {
    cleanup_tracer();
    exit(WEXITSTATUS(status));
  }
}


static void dynamic_sandboxing(int *parsed_syscalls, int pos) {
    debug("Using dynamic sandboxing\n");
    signal(SIGINT, sig_handler);
    // first we fork, let the child wait for a signal while parent installs its seccomp filter
    child = fork();
    if(child == 0) {
      // Finally install the dynamic seccomp filter
      scmp_filter_ctx ctx;
      ctx = seccomp_init(SCMP_ACT_TRACE(getpid())); // on default we trace the program, parameter is the process id of our program
      seccomp_attr_set(ctx, SCMP_FLTATR_CTL_LOG, 1);
      // setup whitelist
      if(!getenv("TRACE")) {
        for(int i=0; i<pos; i++) {
          seccomp_rule_add(ctx, SCMP_ACT_ALLOW, parsed_syscalls[i], 0);
        }
      } else {
        debug("I'm in trace mode, no seccomp filter installed\n");
      }
      // ptrace the child process
      ptrace(PTRACE_TRACEME, 0, 0, 0);
      raise(SIGSTOP);
      seccomp_load(ctx);
      seccomp_release(ctx);
    } else {
      waitpid(child, &status, 0);
      ptrace(PTRACE_SETOPTIONS, child, 0, PTRACE_O_TRACESECCOMP | PTRACE_O_TRACECLONE | PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK | PTRACE_O_EXITKILL | PTRACE_O_TRACEEXIT);

      //track previously allowed syscalls
      int changed_pid = child;
      while(1) {
        ptrace(PTRACE_CONT, changed_pid, 0, 0);
        // wait for status change of one of the childs
        changed_pid = waitpid(-1, &status, __WALL);
        debug("[waitpid status of child %d changed: 0x%08x]\n", changed_pid, status);

        // our primary child died, so we also exit
        if(changed_pid == child && WIFEXITED(status)) {
          cleanup_tracer();
          exit(WEXITSTATUS(status));
        }

        else if(status>>8 == (SIGTRAP | (PTRACE_EVENT_EXIT<<8))) {
          ptrace(PTRACE_CONT, changed_pid, 0, 0);
        }

        // ptrace a new process forked by our ptraced child
        else if((status>>8 == (SIGTRAP | (PTRACE_EVENT_CLONE<<8)))
          || (status>>8 == (SIGTRAP | (PTRACE_EVENT_FORK<<8)))
          || (status>>8 == (SIGTRAP | (PTRACE_EVENT_VFORK<<8)))) {
            long newpid;
            ptrace(PTRACE_GETEVENTMSG, changed_pid, NULL, (long) &newpid);
            debug("forked, new childs pid: %ld\n", newpid);
            ptrace(PTRACE_CONT, newpid, 0, 0);
        }
        // check if the change in status of the child was due to seccomp
        else if(status>>8 == (SIGTRAP | (PTRACE_EVENT_SECCOMP<<8))) {
          debug("called forbidden syscall\n");
          // get the syscall number that caused us to get here
          #ifdef __x86_64__
          int syscall_number = ptrace(PTRACE_PEEKUSER, changed_pid, sizeof(long)*ORIG_RAX, 0);
          #else
          struct user_regs_struct regs;
          struct iovec iovec;
          iovec.iov_base = &regs;
          iovec.iov_len = sizeof(regs);

          ptrace(PTRACE_GETREGSET, changed_pid, (void*)NT_PRSTATUS, &iovec);
          int syscall_number = regs.regs[8]; // extract syscall number from register x8
          #endif
          debug("%d\n", syscall_number);
          // if not previously allowed, asked the user
          if(syscalls_allowed[syscall_number] != 1) {
            char question[256];
            sprintf(question, "%s --yesno 'Process (%d) wants to perform syscall %d. Do you want to allow it?'", (getenv("TOOL")) ? getenv("TOOL") : "true", changed_pid, syscall_number);
            int question_result = system(question);
            debug("Return value: %d\n", question_result);
            // user said no, kill the child, the offending process, and the tracer
            if(question_result != 0) {
              kill(child, SIGKILL);
              kill(changed_pid, SIGKILL);
              exit(1);
            } else {
              // remember that the syscall was previously allowed
              syscalls_allowed[syscall_number] = 1;
            }
          }
        }
        // if the child receives a signal that was not handled, it gets killed by the OS
        // WIFSIGNALED indicates that this happened
        else if(WIFSIGNALED(status)) {
          if(child == changed_pid) {
            cleanup_tracer();
            exit(1);
          }
        }
        // if a child receives a signal, the tracer is first notified of it
        // we want to forward the signal without additional checks
        else if(WIFSTOPPED(status)) {
          siginfo_t sig;
          ptrace(PTRACE_GETSIGINFO, changed_pid, NULL, &sig);
          if(sig.si_signo != SIGTRAP) {
            ptrace(PTRACE_CONT, changed_pid, 0, WSTOPSIG(status));
          }
        }
      }
    }
}

static void static_sandboxing(int *parsed_syscalls, int pos) {
    debug("Using static sandboxing\n");
    // Finally install the static seccomp filter
    scmp_filter_ctx ctx;
    ctx = seccomp_init(SCMP_ACT_KILL); // on default we trace the program, parameter is the process id of our program

    // setup whitelist
    for(int i=0; i<pos; i++) {
      seccomp_rule_add(ctx, SCMP_ACT_ALLOW, parsed_syscalls[i], 0);
    }
    seccomp_load(ctx);
    seccomp_release(ctx);
}

static void install_sandboxing(int *parsed_syscalls, int pos) {
  if((getenv("DYNAMIC") || exec_needed == 1 || getenv("TRACE")) && !getenv("STATIC"))
    dynamic_sandboxing(parsed_syscalls, pos);
  else
    static_sandboxing(parsed_syscalls, pos);
}

static void __attribute__((section(".sandboxing"), constructor)) setup_seccomp() {
  size_t start = nospecrdtsc();

  // seccomp is already running, we cannot install additional filters due to no_new_privs flag
  if(check_seccomp_active() != 0)
    return;

  _cleanup_free_ int *parsed_syscalls = NULL;
  int pos = parse_syscalls(&parsed_syscalls);

  if(parsed_syscalls && pos > 0) {
    // Finally install the seccomp filter
    install_sandboxing(parsed_syscalls, pos);

    debug("[auto-sandbox] active, took %zd cycles\n", nospecrdtsc() - start);
  } else {
    debug("No seccomp filter to load\n");
  }
}

// We have to include notes for a few functions that musl implements in .S files as
// we cannot extract the required information from them in our static approach.
#include "autosandboxing.h"

#ifdef __x86_64__
CALL_NOTE(__clone, "i32 (i32 (i8*)*, i8*, i32, i8*, ...)", "56,60", "", "\"i32 (i8*)\"")
SYSCALL_NOTE(__set_thread_area, "i32 (i8*)", "158")
SYSCALL_NOTE(vfork, "i32 ()", "58")
#endif

SYSCALL_NOTE(memcpy, "i8* (i8*, i8*, i64)", "")
SYSCALL_NOTE(memmove, "i8* (i8*, i8*, i64)", "")
SYSCALL_NOTE(memset, "i8* (i8*, i32, i64)", "")
